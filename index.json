[{"categories":[""],"content":"1.Flutter简介 什么是Flutter？ Flutter是Google开发的开源UI软件开发工具包，用于构建块平台的移动、Web、和桌面应用程序 Flutter的工作原理是什么？ Flutter使用Dart语言编写，它有自己的渲染引擎，可以直接编译成本地代码。Flutter不依赖于任何平台的原生组件，而是使用自己的高性能渲染引擎来绘制Widget。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"2. Flutter的优点 跨平台开发： 使用一套代码库就可以构建iOS、Android、Web和桌面应用程序 热重载：开发者可以即时看到应用的更改，无需重新启动应用，提高开发效率 性能接近原生：由于Flutter的应用是直接编译为机器码，这使得其性能接近于原生应用。Flutter的渲染过程是独立于原生平台的，这意味着不管运行在哪个平台，应用都能保持一致的性能特性 丰富的组件和开源库：Flutter提供了大量可以即时使用的UI组件，同时社区也提供了丰富的插件支持 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"3.FLutter的缺点 包体积较大：由于Flutter需要包含自己的渲染引擎和其他组件，使用Flutter开发的App往往比使用原生代码开发的App要大。这可能会影响到最终用户的下载和安装体验。 学习曲线：尽管Flutter的入门相对简单，但其背后的语言Dart可能不像JavaScript或Python那样普及。因此，初学者可能需要时间来适应Dart语言及Flutter框架。 平台适配：尽管Flutter力求在各平台上保持一致性，但事实上每个平台都有自己的特色和设计准则。在某些情况下，开发者可能需要针对特定平台进行额外的调整和优化，以确保应用能够良好地融入不同的操作系统环境中。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"4.描述Flutter的架构 Flutter 被设计为一个可扩展的分层系统。它可以被看作是各个独立的组件的系列合集，上层组件各自依赖下层组件。组件无法越权访问更底层的内容，并且框架层中的各个部分都是可选且可替代的。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"1.架构层 引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。 通常，开发者可以通过 Flutter 框架层 与 Flutter 交互，该框架提供了以 Dart 语言编写的现代响应式框架。它包括由一系列层组成的一组丰富的平台，布局和基础库。从下层到上层，依次有： 基础的 foundational 类及一些基层之上的构建块服务，如 animation、 painting 和 gestures，它们可以提供上层常用的抽象。 渲染层 用于提供操作布局的抽象。有了渲染层，你可以构建一棵可渲染对象的树。在你动态更新这些对象时，渲染树也会自动根据你的变更来更新布局。 widget 层 是一种组合的抽象。每一个渲染层中的渲染对象，都在 widgets 层中有一个对应的类。此外，widgets 层让你可以自由组合你需要复用的各种类。响应式编程模型就在该层级中被引入。 Material 和 Cupertino 库提供了全面的 widgets 层的原语组合，这套组合分别实现了 Material 和 iOS 设计规范。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:4:1","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"2.引擎层 Flutter 引擎 毫无疑问是 Flutter 的核心，它主要使用 C++ 编写，并提供了 Flutter 应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了 Flutter 核心 API 的底层实现，包括图形（在 iOS 和 Android 上通过 Impeller，在其他平台上通过 Skia）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。 引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:4:2","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"3.嵌入层 这一层负责与不同操作系统的具体实现交互，例如iOS、Android、Windows、Mac或Linux。嵌入层通过平台特定的代码将Flutter应用集成到宿主操作系统中，处理如启动、消息循环和插件架构等任务。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:4:3","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"5. Flutter如何实现跨平台开发 统一渲染引擎 Flutter 使用自己的高性能渲染引擎（基于Impeller/Skia图形库）来绘制UI，这意味着它不依赖于平台特定的UI组件。无论在哪个平台上运行，Flutter 都是直接在画布上绘制UI，确保了各平台间UI的一致性和性能。 单一代码库 Flutter 允许开发人员使用单个代码库为多个平台（例如 iOS、Android、Web 和桌面）构建应用程序。这意味着您不需要为每个平台单独编写代码。您的应用程序的逻辑、UI 和业务逻辑代码可以在所有平台之间共享。 平台特定功能 尽管Flutter UI的渲染是平台无关的，但它通过平台通道（platform channels）允许开发者访问特定平台的API（如摄像头、位置服务等）。这种机制允许Flutter应用调用原生代码，如Java（或Kotlin）对于Android，以及Objective-C（或Swift）对于iOS ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"6.Flutter与React Native相比有什么优势？ Flutter 的优势： 性能：Flutter 使用自定义渲染引擎，提供流畅的 UI 体验，尤其适合具有复杂动画和图形内容的应用程序。 Flutter 的性能通常优于 React Native。 跨平台兼容性：Flutter 旨在实现真正的跨平台体验。与 React Native 不同，Flutter 应用程序的 UI 呈现与平台的本机控件不同。这意味着应用程序的外观和感觉在所有平台上保持一致，并且不需要额外的努力来实现本机外观。 开发效率：Flutter 使用 Dart 语言，该语言具有快速编译时间和强大的开发工具，包括热重载功能。这意味着您可以实时查看代码更改，从而提高开发效率。 Flutter 的部件系统也使其更容易构建复杂的 UI。 完全可定制：Flutter 提供对像素级控件的访问，允许开发人员完全自定义应用程序的外观和感觉。 Flutter 的灵活性使其能够创建高度定制的 UI，而无需依赖平台特定的设计语言。 社区和生态系统：Flutter 拥有不断增长的社区和生态系统，提供了各种插件和工具来扩展应用程序的功能。 Flutter 还得到了 Google 的支持，这意味着它有良好的文档、资源和长期支持。 Flutter 的劣势： 学习曲线：Flutter 使用 Dart 语言，这对于已经熟悉 JavaScript 或 TypeScript 的开发人员来说是一个额外的学习曲线。 React Native 利用现有的 React 和 JavaScript 知识，使其对具有 Web 开发背景的开发人员更具吸引力。 社区大小：React Native 拥有更大的社区和更成熟的生态系统。这意味着您可以获得更多第三方库、插件和在线资源的支持。 Flutter 社区正在增长，但可能无法与 React Native 的成熟度相媲美。 本机模块集成：虽然 Flutter 提供了对平台特定功能的访问，但与 React Native 相比，本机模块集成的复杂性可能更高。 React Native 具有更广泛的社区支持，使其更容易访问和集成本机模块。 应用程序大小：Flutter 应用程序的初始下载大小可能大于 React Native 应用程序。这可能是 Flutter 应用程序中包含渲染引擎的结果。较大的应用程序大小可能会影响应用程序的下载和安装。 企业采用：React Native 已经在企业中广泛采用，并且拥有更大的企业支持基础。 Flutter 正在获得动力，但可能需要一些时间才能达到 React Native 在企业采用方面的水平。 总之，Flutter 提供出色的性能、完全可定制的 UI 和流畅的开发体验。另一方面，React Native 受益于更大的社区、更成熟的生态系统和现有的 JavaScript 知识。选择哪个框架取决于您的特定要求、项目需求和开发团队的技能。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"7. final,static,const有什么区别？ 1,final final关键字用于声明只能复制一次的变量，一旦final变量被复制，它的值就不能被改变 final变量的值不需要在编译时确定，可以在运行时赋值 final可以用于局部变量，实例变量和全局变量 2，const const关键字用于生命编译时常量，这意味着const变量的值必须在编译时就已知，并且不能改变 const变量通常用于定义不会改变且在编程时已知的值。 const可以用于局部变量、实例变量和全局变量。 3，static static关键字用于声明类级别的变量和方法，这意味着它们属于类本身，而不是类的任何实例。 static变量在内存中只有一个副本，无论你创建了多少个类的实例，所有实例都会共享这个static变量。 static方法或变量可以通过类名直接访问，而不需要创建类的实例。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"使用场景和功能 1， 静态变量 静态变量用于存储类级的数据，这些数据与类的任何实例无关。例如，你可能有一个Widget类，该类需要跟踪所有实例的数量。这可以通过一个static变量实现，因为这个计数是整个类共享的，而不是单个实例独有的。 class MyWidget { static int instanceCount = 0; MyWidget() { instanceCount++; } } 在这个例子中，每次创建MyWidget的新实例时，instanceCount都会增加，而这个变量是所有实例共享的。 2, 静态方法 静态方法是那些可以在不创建类实例的情况下调用的方法。它们通常用于执行不依赖于对象状态的功能。例如，你可能有一个工具类，它包含了一些实用的功能，这些功能本身不需要访问类的任何非静态字段。 class Utils { static int add(int a, int b) { return a + b; } } 你可以直接通过类名调用这个方法，如Utils.add(1, 2)，而不需要创建Utils的实例。 3,静态构造函数 在Dart中，构造函数不能被声明为静态的。然而，你可以使用静态方法来实现工厂构造函数的模式，这允许你控制类实例的创建过程。 例如，你可以创建一个单例模式，其中只有一个类的实例被创建。 class Singleton { static final Singleton _instance = Singleton._internal(); Singleton._internal(); static Singleton get instance =\u003e _instance; } 在这个例子中，Singleton类使用一个私有的构造函数和一个静态的访问方法来实现单例模式。这确保了类的全局唯一实例。 在Flutter开发中，使用static变量和方法可以帮助你管理全局状态或提供工具函数。然而，需要注意的是，滥用静态状态可能会导致代码难以测试和维护，特别是在大型应用中。此外，静态状态不会自动触发Flutter的构建过程，所以如果你的UI依赖于静态变量的值，你可能需要找到其他方法来确保UI在这些值变化时更新。 总之，static关键字在Flutter（和Dart）中提供了一种方便的方式来声明类级别的数据和方法，但它应该谨慎使用，以避免引入全局状态管理的问题。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:7:1","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"8，extends、implements、with的用法与区别 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:8:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"1 继承：extends Flutter中的继承是单继承 构造函数不能继承 子类重写超类的方法要用@override 子类调用超类的方法要用super Flutter中的子类可以访问父类中的所有变量和方法 class Television { void turnOn() { _illuminateDisplay(); } void _illuminateDisplay(){ } } class SmartTelevision extends Television { void turnOn() { super.turnOn(); _bootNetworkInterface(); } void _bootNetworkInterface(){ } } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:8:1","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"2 接口实现：implements Flutter是没有interface的，但是Flutter中的每个类都是一个隐式的接口，这个接口包含类里的所有成员变量以及定义的方法 当class被当作interface用时，class中的方法就是接口的方法，需要在子类里重新实现，在子类实现的时候要加@override class中的成员变量也需要在子类里重新实现，在成员变量前加@override 实现接口可以有多个 抽象类是不能被实例化的类，通常用作其他类的基类。在Dart中，你可以使用abstract关键字来定义抽象类。 abstract class Shape { double get area; } class Circle extends Shape { final double radius; Circle(this.radius); @override double get area =\u003e 3.14 * radius * radius; } class Circle implements Shape { final double radius; Circle(this.radius); @override double get area =\u003e 3.14 * radius * radius; } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:8:2","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"4, implements和extends有什么区别? extends 用途：extends用于设置一个类的父类。子类继承父类的所有属性和方法，可以对这些方法进行重写（override），也可以调用父类的方法。 单继承：在Dart中，一个类只能继承一个父类。这意味着通过extends关键字，一个子类只能有一个直接的父类。 构造函数：在子类中，你必须显式调用父类的构造函数（如果父类没有无参构造函数的话）。 class Animal { void breathe() { print(\"Breathing\"); } } class Dog extends Animal { void bark() { print(\"Barking\"); } } 在这个例子中，Dog类继承了Animal类，因此Dog的实例可以调用breathe()方法。 implements 用途：implements用于实现一个或多个接口。一个类可以实现多个接口，必须提供这些接口中所有方法的具体实现。 多接口实现：使用implements关键字，一个类可以实现多个接口，这提供了一种形式的多重继承，因为你可以从多个源继承行为的契约（即接口定义的方法）。 完全重写：实现接口时，必须完全实现接口中声明的所有方法，即使这些方法在接口中已经有了实现（Dart的接口可以包含实现）。 class Animal { void breathe() { print(\"Breathing\"); } } class Dog implements Animal { @override void breathe() { print(\"Dog breathing\"); } void bark() { print(\"Barking\"); } } 在这个例子中，Dog类实现了Animal类作为接口。Dog必须提供breathe()方法的实现，即使Animal中已经有了实现。 总结： 继承 vs 实现：extends是用来继承一个类的功能，包括属性和方法；而implements是用来实现一个或多个接口，需要提供所有接口方法的具体实现。 代码重用：通过extends，子类自动获得父类的方法和属性，可以直接使用或进行扩展；而通过implements，类只获得方法的签名，必须提供每个方法的具体实现。 设计意图：extends通常用于表达“是一个”关系，即子类是父类的一种特殊形式；implements用于表达“像一个”关系，即类可以按照一个或多个接口的规范行事，但不继承任何实现。 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:8:3","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"5, 混入：mixins 混入（Mixin）是一种在多类继承中重用类代码的方式。在Dart中，使用mixin关键字定义混入，并通过with关键字将其应用于其他类。 mixin Musical { void playMusic() { print('Playing music...'); } } class MusicCar extends Car with Musical { } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:8:4","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"异步编程 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:9:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Future async,await Future是dart中用于表示一部操作的结果的一个对象，它代表一个可能还未完成的异步操作，并提供了一种方法来处理一旦操作完成时的结果 Future\u003cString\u003e fetchUserData() { // 模拟一个网络请求 return Future.delayed(Duration(seconds: 2), () { return \"User data loaded\"; }); } void main() { fetchUserData().then((data) { print(data); // 打印结果 }).catchError((error) { print(\"An error occurred.\"); }); } async和await关键字用于简化异步编程，当在函数前加上async标记，就可以在内部实用await关键字，await会暂停当前的一部函数直到等待的flutter完成，然后继续执行函数 Future\u003cString\u003e fetchUserData() { return Future.delayed(Duration(seconds: 2), () { return \"User data loaded\"; }); } Future\u003cvoid\u003e printUserData() async { try { String data = await fetchUserData(); print(data); } catch (error) { print(\"An error occurred.\"); } } void main() { printUserData(); } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:9:1","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Stream stream是dart中用于处理异步数据流的对象，它代表一个连续的异步事件序列，可以通过订阅来接收这些事件，并在需要时处理它们。与future处理单个异步响应不同，stream可以提供多个异步事件的队列 Stream\u003cint\u003e timedCounter(Duration interval, int maxCount) { StreamController\u003cint\u003e controller; Timer timer; int counter = 0; void tick(_) { counter++; controller.add(counter); // 向流中添加事件 if (counter == maxCount) { timer.cancel(); controller.close(); // 关闭流 } } void startTimer() { timer = Timer.periodic(interval, tick); } controller = StreamController\u003cint\u003e( onListen: startTimer, ); return controller.stream; } void main() { timedCounter(Duration(seconds: 1), 5).listen((int counter) { print(counter); // 打印值 1, 2, 3, 4, 5 }); } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:9:2","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"错误处理 - 异常捕获 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:10:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"1，异常类型 Error ： 如RangeError，TypeError等，这类错误通常应该在开发过程中被修正 Expection: 如文件未找到，网络请求失败等，应该被捕获并适当处理 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:10:1","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"2，抛出异常 实用throw关键字抛出异常 void checkAge(int age) { if (age \u003c 18) { throw Exception(\"You are not old enough.\"); } } ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:10:2","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"3，捕获异常 实用try-catch语句捕获异常 try { checkAge(17); } on Exception catch (e) { print('Caught an exception: $e'); } catch (e) { print('Caught a generic exception'); } finally { print('This block runs whether an exception is thrown or not.'); } on Exception catch（e）用于捕获特定类型异常，catch(e)用于捕获任何违背之前on语句捕获的异常，finally块无论是否发生异常都会执行，常用于资源清理操作 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:10:3","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"4，自定义异常 class CustomException implements Exception { String cause; CustomException(this.cause); } void main() { try { throwException(); } on CustomException { print(\"custom exception has been obtained\"); } } throwException() { throw new CustomException('This is my first custom exception'); } 面试题示例： ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:10:4","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"请解释Dart中final和const的区别。 1， 编译时与运行时 final： 变量只能被赋值一次，并且可以在运行时被初始化，这意味着final变量的值可以在运行时决定 const：必须在编译时就确定值，因为它用于那些在编写代码时就已知且不会改变的值，const变量不仅其值不能改变，连变量本身在内存中的位置也是固定的 2，使用场景 final：当你不希望变量的值在初始化后被修改，但又需要在运行时确定其值时，实用final const：用于那些在编写代码时完全确定其值的场景，适用与全局常量或类常量 ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:11:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"如何在Dart中实现多重继承？ Dart的集成是单继承，只能有一个父类，子类会集成父类所有非私有属性和方法 抽象类能被实例化，只能被子类集成。 虽然Dart不支持多继承，但支持多个implements， 混合mixin，一个类可以混合多个mixin类，mixin类不能继承 解释Dart的异步支持，包括Future和Stream。 Dart中的异常处理机制是怎样的？ ","date":"2024-04-19","objectID":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/:12:0","tags":["Flutter","Dart"],"title":"Fluter 知识点","uri":"/posts/flutter%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["娱乐"],"content":"【沙丘2】: 磁力链接 sh【功夫熊猫4】:magnet:?xt=urn:btih:e0a4c058019fb15c0b2464b9caa8aa3d0ffa58b1\u0026dn=阳光电影dygod.org.功夫熊猫4.2024.BD.1080P.中英双字.mkv\u0026tr=udp://tracker.opentrackr.org:1337/announce\u0026tr=udp://exodus.desync.com:6969/announce 【养蜂人The Beekeeper】（反诈宣传片）：magnet:?xt=urn:btih:68988dea2902772bc34a3588e7135e6aad67ac95\u0026dn=阳光电影dygod.org.养蜂人.2024.BD.1080P.国英双语中字.mkv\u0026tr=udp://tracker.opentrackr.org:1337/announce\u0026tr=udp://exodus.desync.com:6969/announce ","date":"2024-04-08","objectID":"/posts/%E5%BD%B1%E8%A7%86%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/:0:0","tags":null,"title":"影视资源分享","uri":"/posts/%E5%BD%B1%E8%A7%86%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"},{"categories":["教程"],"content":" 计划使用Hugo+GitHub Actions自动部署blog，在这过程中遇到不少坑，特此记录，以供参考 ","date":"2024-04-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:0:0","tags":["hugo"],"title":"Hugo搭建Blog教程踩坑指南","uri":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["教程"],"content":"个人方案 两个GitHub仓库，一个用来存放blog项目，并使用自动部署deploy静态网站到divvspace.github.io仓库，这样就可以只操作blog项目即可，每次有更新直接push到远端即可。 blog仓库： 存储Hugo项目，把/public/文件下内容deploy到divvspace.github.io divvspace.github.io： Hugo项目生成的静态网站 主题安装问题 直接clone主题到themes文件夹会导致无法添加主题项目文件到git，theme文件夹为空。 解决办法：使用官方建议的方法 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 主题安装及配置参考教程 ","date":"2024-04-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:0:1","tags":["hugo"],"title":"Hugo搭建Blog教程踩坑指南","uri":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["教程"],"content":"自动化操作 生成ssh-key ssh-keygen -t rsa -b 4096 -C \"{{your_email@example.com}}\" divvspace.github.io仓库 Setting - Security - Deploy keys设置上面生成的公钥 要勾选Allow write access Blog项目仓库 在项目目录下添加.github/workflows/deploy.yml文件 name: Auto Deploy hugo on: push: workflow_dispatch: schedule: # 定时执行 - cron: \"0 2 * * *\" jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - name: Check out repository code uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # secret 中设置好私钥，名称和上面设置的一样 external_repository: DivvSpace/DivvSpace.github.io # Page 仓库地址 publish_branch: master # Page 仓库的分支 publish_dir: ./public # 静态网页路径 commit_message: ${{ github.event.head_commit.message }} Blog项目仓库Setting- Secrets and variables - Actions - New repostiory secret添加私钥 名字与deeply.yml中保持一致。 ","date":"2024-04-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:0:2","tags":["hugo"],"title":"Hugo搭建Blog教程踩坑指南","uri":"/posts/hugo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["教程"],"content":"Rust Rust语言圣经(Rust Course)：https://course.rs/about-book.html JavaScript JavaScript框架语法特性对比 ","date":"2024-04-08","objectID":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/:0:0","tags":["Rust"],"title":"学习资料收集","uri":"/posts/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"},{"categories":null,"content":"为什么叫佚名？ 因为小时候看作文书，看报纸什么的，有一个人的文章最多，就是叫佚名，当时就想：这哥们真牛逼，能写那么多文章，还都是不同类型的，有小学生作文，有小说，有散文什么的，牛啊！ 我是一位程序员， iOS开发出身，开始用OC，后来swift，后来出了flutter跨平台，就开始搞flutter，后来就失业了，现在想做自由开发者，但是没什么想法，有想法的小伙伴们请@我，有力出力。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]